<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>二.进程，处理机调度与死锁（二） | Taoblog</title><meta name="keywords" content="categories-java"><meta name="author" content="廖涛"><meta name="copyright" content="廖涛"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="摘要： 进程同步，进程互斥 信号量机制，管程的概念 死锁">
<meta property="og:type" content="article">
<meta property="og:title" content="二.进程，处理机调度与死锁（二）">
<meta property="og:url" content="http://taoblog421.cn/article/bb449d20.html">
<meta property="og:site_name" content="Taoblog">
<meta property="og:description" content="摘要： 进程同步，进程互斥 信号量机制，管程的概念 死锁">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://edu-cubeonline.oss-cn-chengdu.aliyuncs.com/8338e032aa164b37a69adee487bf10a81.jpg">
<meta property="article:published_time" content="2020-09-02T13:37:39.000Z">
<meta property="article:modified_time" content="2022-03-19T08:55:37.458Z">
<meta property="article:author" content="廖涛">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://edu-cubeonline.oss-cn-chengdu.aliyuncs.com/8338e032aa164b37a69adee487bf10a81.jpg"><link rel="shortcut icon" href="https://edu-cubeonline.oss-cn-chengdu.aliyuncs.com/456a1d060f1442f8bf1921de16285b7c22.png"><link rel="canonical" href="http://taoblog421.cn/article/bb449d20"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1cd7f0388005bdbb53d2ff9b9a1a295a";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 廖涛","link":"链接: ","source":"来源: Taoblog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '二.进程，处理机调度与死锁（二）',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2022-03-19 16:55:37'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://at.alicdn.com/t/font_3258369_333fi1pi48t.css"><meta name="generator" content="Hexo 6.1.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/05/TatLkECB7mx1ZGd.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">100</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-wenzhang"></i><span> 文章:</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw iconfont icon-liuyanban-05"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyuwomen"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://edu-cubeonline.oss-cn-chengdu.aliyuncs.com/8338e032aa164b37a69adee487bf10a81.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Taoblog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-wenzhang"></i><span> 文章:</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw iconfont icon-liuyanban-05"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyuwomen"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">二.进程，处理机调度与死锁（二）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-02T13:37:39.000Z" title="发表于 2020-09-02 21:37:39">2020-09-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-19T08:55:37.458Z" title="更新于 2022-03-19 16:55:37">2022-03-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="二.进程，处理机调度与死锁（二）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/article/bb449d20.html#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/article/bb449d20.html" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>摘要：</p>
<p>进程同步，进程互斥</p>
<p>信号量机制，管程的概念</p>
<p>死锁</p>
</blockquote>
<span id="more"></span>

<h3 id="2-3-1-进程同步，进程互斥"><a href="#2-3-1-进程同步，进程互斥" class="headerlink" title="2.3_1 进程同步，进程互斥"></a>2.3_1 进程同步，进程互斥</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1.什么是进程同步</span><br><span class="line">    进程的异步，各个并发的进程，以各自独立的，不可预知的速度向前推进</span><br><span class="line"></span><br><span class="line">    同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在</span><br><span class="line">    某些位置上协调他们的工作次序而产生制约关系，进程间的直接制约关系就是源于他们之间的相互</span><br><span class="line">    合作</span><br><span class="line">2.什么是进程互斥</span><br><span class="line">    进程的“并发”需要“共享”的支持，各个并发执行的进程不可避免的需要共享一些系统资源（比如</span><br><span class="line">    内存，打印机，摄像头这样的I/O设备）</span><br><span class="line"></span><br><span class="line">    我们把一时间段内只允许一个进程使用的资源称为临界资源。许多物理设备（比如摄像头，打印机）</span><br><span class="line">    都属于临界资源。此外还有许多变量，数据，内存缓冲区都属于临界资源</span><br><span class="line"></span><br><span class="line">    对临界资源的访问，必须互斥的进行。互斥，亦称间接制约关系。进程互斥指当一个进程访问某临界</span><br><span class="line">    资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束时，释放</span><br><span class="line">    资源后，另一个进程才能去访问临界资源</span><br><span class="line"></span><br><span class="line">    对临界资源的互斥访问，可以在逻辑上分为四个部分</span><br><span class="line"></span><br><span class="line">    进入区 负责检查是否可以进入临界区，若可进入，则应设置正在访问临界区的标志（上锁），</span><br><span class="line">            以阻止其他进程同时进入临界区</span><br><span class="line">    临界区 访问临界资源的那段代码</span><br><span class="line">    退出区 负责解除正在访问临界资源的标志（解锁）</span><br><span class="line">    剩余区 做其他处理</span><br><span class="line"></span><br><span class="line">    为了实现对临界进程的互斥访问，同时保证系统的整体性，需要遵循以下原则</span><br><span class="line"></span><br><span class="line">    1.空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</span><br><span class="line">    2.忙则等待。已经有程序进入临界区时，其他试图进入临界区的进程必须等待</span><br><span class="line">    3.有限等待。对请求访问的进程，应保证在有限的时间内进入临界区</span><br><span class="line">    4.让权等待。当进程不能进入处理机，应立即释放处理机，防止进程忙等待</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-进程互斥的软件实现方法"><a href="#2-3-2-进程互斥的软件实现方法" class="headerlink" title="2.3_2 进程互斥的软件实现方法"></a>2.3_2 进程互斥的软件实现方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">Tips:</span><br><span class="line">    1.理解各个算法的思想，原理</span><br><span class="line">    2.结合上小结学习“实现互斥的四个逻辑部分”，重点理解各算法在进入区，退出区都做了什么</span><br><span class="line">    3.分析各算法存在的缺陷（结合“进程互斥的四个原则”进程分析）</span><br><span class="line"></span><br><span class="line">1.单标志法</span><br><span class="line">    算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程，也就是说每个进程访问</span><br><span class="line">    临界区的权限只能由另一个进程赋予</span><br><span class="line"></span><br><span class="line">    int turn = 0; //turn 表示当前允许进入临界区的进程号</span><br><span class="line"></span><br><span class="line">    p0进程：                       p1进程</span><br><span class="line">    while(turn != 0);           while(turn != 1);</span><br><span class="line">    critical section;           critical section;</span><br><span class="line">    turn = 1;                   turn = 0;</span><br><span class="line">    remainder section;          remainder section;</span><br><span class="line"></span><br><span class="line">    对于临界区的访问，一定是按p0 -&gt; p1 -&gt; p0 -&gt; p1 这样轮流访问的。这种必须轮流访问带来的问题是</span><br><span class="line">    ，如果此时允许进入临界区的进程是p0,而p0一直不访问临界区，那么此时临界区空闲，但是并不允许p1</span><br><span class="line">    访问</span><br><span class="line"></span><br><span class="line">    因此但单标志法存在的主要问题是：违背“空闲让进”原则</span><br><span class="line"></span><br><span class="line">2.双标志先检查法</span><br><span class="line">    算法思想：设置一个布尔类型的数组flag[]，数组中的各个元素用来标记各个进程想进入临界区的意愿，</span><br><span class="line">        比如“flag[0] = ture”意味着零号进程现在想要进入临界区，每个进程在进入临界区之前先检查当前</span><br><span class="line">        有没有别的进程想进入临界区，如果没有，则把自身对应的flag[i]设置为true,之后开始访问临界区</span><br><span class="line"></span><br><span class="line">    bool flag[2]; //表示进入临界区意愿的数组</span><br><span class="line">    flag[0] = false;</span><br><span class="line">    flag[1] = false; //刚开始两个进程都不想进入临界区</span><br><span class="line"></span><br><span class="line">    p0进程：                   p1进程：</span><br><span class="line">    while(flag[1]);   1     while(flag[0]);   5</span><br><span class="line">    flag[0] = true;   2     flag[1] = true;   6</span><br><span class="line">    cirtical section; 3     critical section; 7</span><br><span class="line">    flag[0] = false;  4     flag[1] = false;  8</span><br><span class="line">    remainder section;      remainder section;</span><br><span class="line"></span><br><span class="line">    如果按照 1 5 2 6 3 7 4 8 的顺序执行，p0,p1将会同时访问临界区</span><br><span class="line">    双标志法存在的主要问题：违背“忙则等待”原则</span><br><span class="line">    原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的，“检查”后，“上锁”前可能发生进程切换</span><br><span class="line"></span><br><span class="line">3.双标志后检查法</span><br><span class="line">    算法思想：双标志先检查法，前一个算法的问题是先“检查”，后“上锁”，但是这两个操作又无法一气呵成，</span><br><span class="line">        因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法来避免上述</span><br><span class="line">        问题</span><br><span class="line"></span><br><span class="line">    bool flag[2]; //表示进入临界区意愿的数组</span><br><span class="line">    flag[0] = false;</span><br><span class="line">    flag[1] = false; //刚开始两个进程都不想进入临界区</span><br><span class="line"></span><br><span class="line">    p0进程：                   p1进程：</span><br><span class="line">    flag[0] = true;   1     flag[1] = true;   5</span><br><span class="line">    while(flag[1]);   2     while(flag[0]);   6</span><br><span class="line">    cirtical section; 3     critical section; 7</span><br><span class="line">    flag[0] = false;  4     flag[1] = false;  8</span><br><span class="line">    remainder section;      remainder section;</span><br><span class="line"></span><br><span class="line">    如果按照 1 5 2 6 执行 p0和p1都无法进入临界区</span><br><span class="line"></span><br><span class="line">    双标志后检查法虽然解决了“忙则等待”的问题，但又导致了“空闲让进”，“有限等待”的原则，</span><br><span class="line">    会因各进程长期无法访问临界区资源而产生“饥饿”现象</span><br><span class="line"></span><br><span class="line">4.Peterson算法</span><br><span class="line">    算法思想：双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后都无法进入临界区。</span><br><span class="line">        Gary L.Peterson 想到了一种方法，如果双方都争着进入临界区，那可以让进程尝试“孔融让梨”，</span><br><span class="line">        主动让对方先进入临界区</span><br><span class="line"></span><br><span class="line">    bool flag[2];//表示进入临界区意愿的数组，初始值都是false</span><br><span class="line">    int turn = 0;//turn 表示优先让哪个进程进入临界区</span><br><span class="line"></span><br><span class="line">    p0进程：</span><br><span class="line">    flag[0] = true;                     1</span><br><span class="line">    turn = 1;                           2</span><br><span class="line">    while(flag[1] &amp;&amp; turn == 1);        3</span><br><span class="line">    critical section;</span><br><span class="line">    flag[0] = false;</span><br><span class="line">    remainder section;</span><br><span class="line"></span><br><span class="line">    p1进程：</span><br><span class="line">    flag[1] = ture;                     4</span><br><span class="line">    turn = 0;                           5</span><br><span class="line">    while(flag[0] &amp;&amp; turn = 0);         6</span><br><span class="line">    critical section;</span><br><span class="line">    flag[1] = false;</span><br><span class="line">    remainder section;</span><br><span class="line"></span><br><span class="line">    Peterson算法解决了进程互斥问题，遵循“空闲让进”，“忙则等待”，“有限等待”三个原则，但依然未能遵循</span><br><span class="line">    “让权等待”,想比之前三种算法，是最好的，但是依然不够好</span><br></pre></td></tr></table></figure>

<h3 id="2-3-3-进程互斥的硬件实现方法"><a href="#2-3-3-进程互斥的硬件实现方法" class="headerlink" title="2.3_3 进程互斥的硬件实现方法"></a>2.3_3 进程互斥的硬件实现方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">Tips:</span><br><span class="line">    1.理解各个方法的原理</span><br><span class="line">    2.了解各个方法的优缺点</span><br><span class="line"></span><br><span class="line">1.自断屏蔽方法</span><br><span class="line">    利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被</span><br><span class="line">    中断，也就不能实现进程切换，因此避免了同时访问临界区）</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    关中断； 关中断即不允许当前进程被中断，也必然不会发生进程切换</span><br><span class="line">    临界区；</span><br><span class="line">    开中断；    直到进程访问完临界区，再执行开中断指令，才有可能别的进程上处理机并访问临界区</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    优点：简单，高效</span><br><span class="line">    缺点：不适合多处理机的操作系统；只使用与内核进程，不使用用户进程（开/关中断指令只能运行在内核态</span><br><span class="line">    这组指令让用户随意使用会很危险）</span><br><span class="line"></span><br><span class="line">2.TestAndSet</span><br><span class="line">    简称TS指令，也有地方TestAndSetLock指令，或TSL指令</span><br><span class="line">    TSL指令是硬件实现的，执行的过程不允许被中断，只能一气呵成。以下使用c语言实现的逻辑</span><br><span class="line"></span><br><span class="line">    //bool共享变量lock 表示当前临界区是否加锁</span><br><span class="line">    //true 表示已经加锁，false 表示未加锁</span><br><span class="line"></span><br><span class="line">    bool TestAndSet(bool *lock)&#123;</span><br><span class="line">        bool old;</span><br><span class="line">        old = *lock;  //old存放lock原来的值</span><br><span class="line">        *lock = true; //加锁</span><br><span class="line">        return old; //返回lock原来的值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(TearAndSet(&amp;lock));//上锁并检查</span><br><span class="line">    临界区代码段...</span><br><span class="line">    lock = false //解锁</span><br><span class="line">    剩余区代码段...</span><br><span class="line"></span><br><span class="line">    相比软件实现的方法，TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作</span><br><span class="line">    优点：实现简单，无需像软件实现方法那样严格检查是否有逻辑漏洞；适用于多处理机环境</span><br><span class="line">    缺点：不满足“让权等待” 产生忙等现象</span><br><span class="line"></span><br><span class="line">3.Swap</span><br><span class="line">    有的地方也叫Exchange指令，或简称XCHG指令。</span><br><span class="line">    swap指令是硬件实现的执行的过程不允许被中断，只能一气呵成，以下是C语言逻辑</span><br><span class="line"></span><br><span class="line">    //Swap指令的作用是交换两个变量的值</span><br><span class="line">    Swap(bool *a,bool *b)&#123;</span><br><span class="line">        bool temp;</span><br><span class="line">        temp = *a;</span><br><span class="line">        *a = *b;</span><br><span class="line">        *b = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // bool型 lock 表示当前临界区是否被加锁</span><br><span class="line">    bool old = true;</span><br><span class="line">    while(old == true)</span><br><span class="line">        swap(&amp;lock,&amp;old);</span><br><span class="line">    临界区代码段...</span><br><span class="line">    lock = false;</span><br><span class="line">    剩余区代码段...</span><br><span class="line"></span><br><span class="line">    逻辑上个和TS无太大区别</span><br><span class="line"></span><br><span class="line">    相比软件实现的方法，SWAP指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作</span><br><span class="line">    优点：实现简单，无需像软件实现方法那样严格检查是否有逻辑漏洞；适用于多处理机环境</span><br><span class="line">    缺点：不满足“让权等待” 产生忙等现象</span><br></pre></td></tr></table></figure>

<h3 id="2-3-4-信号量机制"><a href="#2-3-4-信号量机制" class="headerlink" title="2.3_4 信号量机制"></a>2.3_4 信号量机制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">复习回顾+思考：之前学习的这些进程互斥的解决方案分别存在哪些问题？</span><br><span class="line"></span><br><span class="line">进程互斥的四种软件实现方式（单标志法，双标志法先检查，双标志后检查，Peterson）</span><br><span class="line">进程互斥的三种硬件实现方式（中断屏蔽法，TS/TSL指令，Swap/XCHG指令） </span><br><span class="line"></span><br><span class="line">1.单标志检查法只能轮换的执行进程，不满足“空闲让进”</span><br><span class="line">2.双标志先检查法，进入区的“检查”，“上锁”操作无法一气呵成，从而导致了两个进程可能同时进入临界区</span><br><span class="line">    不满足：“忙则等待”</span><br><span class="line">3.双标志后检查法，进去区的“上锁”，“检查”操作无法一气呵成，导致了两个进程都无法进入临界区</span><br><span class="line">    不满足：“空闲让进”，“有限等待”</span><br><span class="line">4.peterson算法,无法实现“让权等待”</span><br><span class="line">5.所有解决方案都无法实现“让权等待”</span><br><span class="line"></span><br><span class="line">1965年,荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥，同步的方法 -- 信号量机制</span><br><span class="line"></span><br><span class="line">1.信号量机制</span><br><span class="line">    用户进程可以通过操作系统提供的一对原语来对信号量进行操作，从而方便的实现了进程互斥与同步</span><br><span class="line"></span><br><span class="line">    信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量表示系统中</span><br><span class="line">    某种资源的数量</span><br><span class="line"></span><br><span class="line">    原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由开中断/关中断指令实现的。软件解决方</span><br><span class="line">    案的主要问题是“进入区的操作不能一气呵成”，因此如果把进入区，退出区的操作使用原语实现，使这些操作</span><br><span class="line">    一气呵成，就能解决问题</span><br><span class="line"></span><br><span class="line">    一对原语：wait(S),signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为wait和signal，括号</span><br><span class="line">    里的信号量S其实就是函数调用时传入的一个参数</span><br><span class="line"></span><br><span class="line">    wait,signal原语常简称为P,V（来自荷兰语）因此，做题的时候可能遇到P(S),V(S)</span><br><span class="line"></span><br><span class="line">2.整型信号量</span><br><span class="line">    用一个整数型的变量作为信号量，用来表示系统中某种资源的数量</span><br><span class="line">    与普通整数型变量的区别:对信号量操作只有三种 初始化，P操作，V操作</span><br><span class="line">    --------------------------------------------------------------------</span><br><span class="line">    EG:某系统只有一台打印机</span><br><span class="line"></span><br><span class="line">    int S = 1;//初始整数型信号量S，表示当前系统中可用的打印机资源数</span><br><span class="line"></span><br><span class="line">    void wait(int S)&#123;</span><br><span class="line">        while(S&lt;=0); //如果资源数不够，就一直循环等待    存在的问题：不满足让权等待，会发生忙等</span><br><span class="line">        S = S - 1;  //如果有资源数够，则占用一个资源</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void signal(int S)&#123;</span><br><span class="line">        S = S + 1; //释放资源</span><br><span class="line">    &#125;</span><br><span class="line">    进程p0:</span><br><span class="line">    ...</span><br><span class="line">    wait(S)       //进入区，申请资源</span><br><span class="line">    使用打印机资源 //临界区，访问资源</span><br><span class="line">    signal(S)     // 退出区，释放资源</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    进程p1:</span><br><span class="line">    ...</span><br><span class="line">    wait(S)       //进入区，申请资源</span><br><span class="line">    使用打印机资源 //临界区，访问资源</span><br><span class="line">    signal(S)     // 退出区，释放资源</span><br><span class="line">    ...</span><br><span class="line">    -------------------------------------------------------------------</span><br><span class="line">    3.记录型信号量 （*超高频出题点）</span><br><span class="line">    整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构标志信号量</span><br><span class="line"></span><br><span class="line">    /*记录型信号量的定义*/</span><br><span class="line">    typedef struct &#123;</span><br><span class="line">        int value; //剩余资源数</span><br><span class="line">        struct process *L; //等待队列</span><br><span class="line">    &#125; semaphore</span><br><span class="line"></span><br><span class="line">    void wait(S)&#123;</span><br><span class="line">        S.value --;</span><br><span class="line">        if(S.value &lt; 0)&#123;</span><br><span class="line">            //如果剩余资源不够，使用block原语使进程从运行态进入阻塞态，并挂到信号量S的等待队列（阻塞队列）</span><br><span class="line">            block(S.L); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void signal(S)&#123;</span><br><span class="line">        S.value ++;</span><br><span class="line">        if(S.value &lt;= 0)&#123;</span><br><span class="line">            //释放资源后，若还有别的进程在等待使用这种资源，则使用wakeup唤醒等待队列中的一个进程，该进程</span><br><span class="line">            从阻塞态变为就绪态</span><br><span class="line">            wakeup(S.L);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ---------------------------------------------------------------------------</span><br><span class="line">    EG:某计算机系统中有两台打印机，则可在初始化信号量S时将value设为1，就绪队列S设为空</span><br><span class="line"></span><br><span class="line">    typedef struct &#123;</span><br><span class="line">        int value; //剩余资源数              ==2</span><br><span class="line">        struct process *L; //等待队列       ==null</span><br><span class="line">    &#125; semaphore</span><br><span class="line"></span><br><span class="line">    进程p0:</span><br><span class="line">    ...</span><br><span class="line">    wait(S)       //进入区，申请资源</span><br><span class="line">    使用打印机资源 //临界区，访问资源</span><br><span class="line">    signal(S)     // 退出区，释放资源</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    进程p1:</span><br><span class="line">    ...</span><br><span class="line">    wait(S)       //进入区，申请资源</span><br><span class="line">    使用打印机资源 //临界区，访问资源</span><br><span class="line">    signal(S)     // 退出区，释放资源</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    进程p2:</span><br><span class="line">    ...</span><br><span class="line">    wait(S)       //进入区，申请资源</span><br><span class="line">    使用打印机资源 //临界区，访问资源</span><br><span class="line">    signal(S)     // 退出区，释放资源</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    进程p3:</span><br><span class="line">    ...</span><br><span class="line">    wait(S)       //进入区，申请资源</span><br><span class="line">    使用打印机资源 //临界区，访问资源</span><br><span class="line">    signal(S)     // 退出区，释放资源</span><br><span class="line">    ...</span><br><span class="line">    （纸上运行一遍....）</span><br><span class="line">    ---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    block原语进行了自我阻塞（当前运行进程从运行态-&gt;就绪态）主动放弃处理机，满足“让权等待”</span><br><span class="line"></span><br><span class="line">    住：若考试中出现了P(S),V(S)操作，除非特殊说明，默认S为记录型信号量</span><br></pre></td></tr></table></figure>

<h2 id="2-3-5-信号量机制"><a href="#2-3-5-信号量机制" class="headerlink" title="2.3_5 信号量机制"></a>2.3_5 信号量机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">1.信号量机制实现进程互斥</span><br><span class="line">    （1）分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应该放在临界区）</span><br><span class="line">    （2）设置互斥信号量mutex,初值为1</span><br><span class="line">    （3）在临界区之前执行P(mutex)</span><br><span class="line">    （4）在临界区之后执行V(mutex)</span><br><span class="line"></span><br><span class="line">    /*信号量机制实现互斥*/</span><br><span class="line">    semaphore mutex  = 1; //初始化信号量</span><br><span class="line"></span><br><span class="line">    p1()&#123;</span><br><span class="line">        ...</span><br><span class="line">        P(mutex);</span><br><span class="line">        临界区代码段...</span><br><span class="line">        V(mutex);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p2()&#123;</span><br><span class="line">        ...</span><br><span class="line">        P(mutex);</span><br><span class="line">        临界区代码段...</span><br><span class="line">        V(mutex);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">2.信号量机制实现进程同步</span><br><span class="line">    进程同步：要让并发执行的进程有序的推进</span><br><span class="line"></span><br><span class="line">    （1）分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）</span><br><span class="line">    （2）设置同步信号量S，初值为0</span><br><span class="line">    （3）在“前操作”之后执行V(S)   //前V后P</span><br><span class="line">    （4）在“后操作”之前执行P(S)</span><br><span class="line"></span><br><span class="line">    要求：代码p4执行一定是在p2之后</span><br><span class="line">    /*信号量机制实现同步*/</span><br><span class="line">    semaphore S = 0； //初始化信号量</span><br><span class="line"></span><br><span class="line">    P1()&#123;</span><br><span class="line">        代码1;</span><br><span class="line">        代码2;</span><br><span class="line">        P(S);</span><br><span class="line">        代码3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    P1()&#123;</span><br><span class="line">        V(S);</span><br><span class="line">        代码4;    </span><br><span class="line">        代码5;</span><br><span class="line">        代码6;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">3.信号量实现进程的前驱关系</span><br><span class="line">    每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）</span><br><span class="line">    因此：</span><br><span class="line">        （1）要为每一对前驱关系各设置一个同步变量</span><br><span class="line">        （2）在“前操作”之后相对应的同步变量执行V操作</span><br><span class="line">        （3）在“后操作”之前相对应的同步变量执行P操作</span><br></pre></td></tr></table></figure>

<h3 id="2-3-6-生产者消费者问题"><a href="#2-3-6-生产者消费者问题" class="headerlink" title="2.3_6 生产者消费者问题"></a>2.3_6 生产者消费者问题</h3><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次产生一个产品放入缓存区，消费者进程每次从缓冲区拿出一个进程并使用（注：这里的产品理解为某种数据）生产者，消费者共享一个初始为空，大小为n的缓冲区 只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待 只有缓冲区不空时，消费者才能从缓冲区取出产品，否则必须等待 缓冲区 是临界资源，各进程必须互斥的访问</p>
<h5 id="pv操作题目分析步骤："><a href="#pv操作题目分析步骤：" class="headerlink" title="pv操作题目分析步骤："></a>pv操作题目分析步骤：</h5><p>1.关系分析。找出题目中描述的各个进程，分析它们之间的同步，互斥关系 2.整理思路。根据各进程的操作流程确定P,V操作的大致顺序 3.设置信号量。设置需要的信号量，并根据题目条件确定信号量初值（互斥信号量一般为1，同步信号量的初始值要看对应资源的初始值是多少）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = 1; //互斥信号量，实现对缓冲区的互斥访问</span><br><span class="line">semaphore empty = n; //同步信号量，表示空闲缓冲区的数量</span><br><span class="line">semaphore full = 0; // 同步信号量，表示产品的数量（非空缓冲区的数量）</span><br><span class="line"></span><br><span class="line">producer() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        生产一个产品；</span><br><span class="line">        P(empty);//消耗一个空闲缓冲区</span><br><span class="line">        p(mutex);</span><br><span class="line">        把产品放入缓冲区;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);//增加一个产品</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(full);//消耗一个产品（非空缓冲区）</span><br><span class="line">        p(mutex);</span><br><span class="line">        从缓冲区拿出一个产品;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);//增加一个空闲缓冲区</span><br><span class="line">        使用产品;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考：能否改变相邻的P,V操作顺序 不能，会发生死锁现象 <strong>实现互斥的P操作一定要放在实现同步的P操作之后</strong> V操作不会导致进程阻塞，因此 <strong>两个V操作的顺序可以交换</strong></p>
<h5 id="知识回顾与重要考点"><a href="#知识回顾与重要考点" class="headerlink" title="知识回顾与重要考点"></a>知识回顾与重要考点</h5><p>生产者消费者问题是一个互斥，同步的综合问题，对于初学者来说最难的是发现题目中隐含的两对同步关系，有时候是消费者需要等待生产者，有时候是生产者要等待消费者，这是两个不同的“一前一后问题”，因此也需要设置两个同步信号量</p>
<h3 id="2-3-7-多生产者消费者问题"><a href="#2-3-7-多生产者消费者问题" class="headerlink" title="2.3_7 多生产者消费者问题"></a>2.3_7 多生产者消费者问题</h3><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放 橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才 可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。 用PV操作实现上述过程。</p>
<h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><p>互斥关系：对缓冲区（盘子）的访问需要互斥的进行 同步关系（一前一后）：</p>
<ol>
<li>父亲将苹果放入盘子后，女儿才能取到苹果</li>
<li>母亲将橘子放入盘子后，儿子才能取得橘子</li>
<li>只有<strong>盘子为空</strong>时，<strong>父亲或母亲</strong>才能放入水果</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = 1;//实现对互斥访问盘子（缓冲区）</span><br><span class="line">semaphore apple = 0;//表示盘子里有几个苹果</span><br><span class="line">semaphore orange = 0;//表示盘子里有几个橘子</span><br><span class="line">semaphore plate = 0;//表示盘子里还能放多少个水果</span><br><span class="line"></span><br><span class="line">dad() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">    准备放一个苹果；</span><br><span class="line">    P(palte);</span><br><span class="line">    p(mutex);</span><br><span class="line">    把苹果放入盘子；</span><br><span class="line">    V(mutex)</span><br><span class="line">    V(apple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mom() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">    准备放一个橘子；</span><br><span class="line">    P(plate);</span><br><span class="line">    p(mutex);</span><br><span class="line">    把橘子放入盘子；</span><br><span class="line">    Vmutex);</span><br><span class="line">    V(orange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sun() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">    P(orange);</span><br><span class="line">    p(mutex);</span><br><span class="line">    从盘子中取出苹果；</span><br><span class="line">    Vmutex);</span><br><span class="line">    V(plate);</span><br><span class="line">    吃掉苹果；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">daughter() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">    P(apple);</span><br><span class="line">    p(mutex);</span><br><span class="line">    从盘0子中取出橘子；</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(plate);</span><br><span class="line">    吃掉橘子;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>去掉实现互斥访问缓冲区的信号量mutex，不会发生多个进程同时访问临界区的现象 原因在于：本题中缓冲区的大小为1，在任何时刻，apple,orange,plate三个同步信号量中最多只有一个是1，因此在任何一个时刻，至少有一个进程的P操作不会被阻塞，并顺利的进入临界区</p>
<h5 id="知识回顾与重要考点-1"><a href="#知识回顾与重要考点-1" class="headerlink" title="知识回顾与重要考点"></a>知识回顾与重要考点</h5><ol>
<li>在生产者消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现访问缓冲区的功能，当然这不是绝对的，要根据问题具体分析</li>
<li>如果在考试过程中来不及分析，可以加上互斥信号量，保证各进程一定互斥的访问临界区，再次注意，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起死锁</li>
<li>解决多生产者消费者问题的关键在于理清复杂的同步关系，在分析同步问题的时候不能从<strong>单个进程行为的角度</strong>来分析，要把<strong>“一前一后”发生的事看做两种“事件的前后关系“</strong></li>
</ol>
<h3 id="2-3-8-吸烟者问题"><a href="#2-3-8-吸烟者问题" class="headerlink" title="2.3_8 吸烟者问题"></a>2.3_8 吸烟者问题</h3><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>假设一个系统有<strong>三个抽烟者进程</strong>和<strong>一个供应者进程</strong>。每个抽烟者不停地卷烟并抽掉它，但是要卷 起并抽掉一支烟，抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中，<strong>第一个拥有烟草、</strong> <strong>第二个拥有纸、第三个拥有胶水</strong>。供应者进程无限地提供三种材料，供应者每次将两种材料放桌 子上，<strong>拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了</strong>，供 应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）</p>
<h5 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h5><p>物品组合 组合1:纸 + 胶水 组合2:烟草 + 胶水 组合3: 烟草 + 纸 互斥关系： 桌子可以抽象为容量为1的缓冲区，需要互斥访问（缓冲区容量为1可以不设置互斥信号量） 同步关系（从事件的角度分析）</p>
<ol>
<li>桌上有组合1 -&gt; 第一个吸烟者取走东西</li>
<li>桌上有组合2-&gt; 第二个吸烟者取走东西</li>
<li>桌上有组合3 -&gt; 第三个吸烟者取走东西</li>
<li>发出完成信号 -&gt; 供应者将下一个组合放到桌上</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓冲区容量为1无需设置互斥信号线</span></span><br><span class="line"><span class="type">semphore</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//桌子上组合1的数量</span></span><br><span class="line"><span class="type">semphore</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//桌子上组合2的数量</span></span><br><span class="line"><span class="type">semphore</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//桌子上组合3的数量</span></span><br><span class="line"><span class="type">sephore</span> <span class="variable">finish</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//是否有人完成吸烟</span></span><br><span class="line">pruducer()&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">            P(finish);</span><br><span class="line">            把组合<span class="number">1</span>放到桌子上；</span><br><span class="line">            V(S1);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">            P(finish);</span><br><span class="line">            把组合<span class="number">2</span>放到桌子上；</span><br><span class="line">            V(S2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            P(finish);</span><br><span class="line">            把组合<span class="number">3</span>放到桌子上；</span><br><span class="line">            V(S3);</span><br><span class="line">        &#125;</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker1() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(s1);</span><br><span class="line">        从桌上拿走组合<span class="number">1</span>，卷烟，吸烟；</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker2() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(s2);</span><br><span class="line">        从桌上拿走组合<span class="number">2</span>，卷烟，吸烟；</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker3() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(s3);</span><br><span class="line">        从桌上拿走组合<span class="number">3</span>，卷烟，吸烟；</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-9-读者-写者问题"><a href="#2-3-9-读者-写者问题" class="headerlink" title="2.3_9 读者-写者问题"></a>2.3_9 读者-写者问题</h3><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不 会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致 数据不一致的错误。因此要求:①允许多个读者可以同时对文件执行读操作;②只允许一个写者 往文件中写信息;③任一写者在完成写操作之前不允许其他读者或写者工作;④写者执行写操作 前，应让已有的读者和写者全部退出。</p>
<h5 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h5><p>两类进程：读进程，写进程 互斥关系：写进程 - 写进程 ，写进程-读进程。读进程与读进程不存在互斥问题 写进程与任何进程都互斥，设置一个信号量rw，在写进程访问共享文件前后分别执行P,V操作。 读者进程和写者进程也要互斥，因此读者进程访问共享文件前后也要对rw执行P,V操作 如果所有读者进程在访问共享文件时都执行P(rw)操作会导致各个读进程之间也无法同时访问文件 <strong>读者-写者问题的核心–怎么解决该问题</strong> <strong>P(rw)和V(rw)其实就是对共享文件的“加锁”和“解锁”。既然各个读进程需要同时访问。而读进程与写进程又必须互斥访问，那么我们可以让第一个访问文件的读进程加锁，让最后一个访问共享文件的读进程解锁。设置一个整型变量count来记录当前有几个读进程在访问文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">seamphore rw = 1;//用于实现对文件的互斥访问，表示当前是否有进程在访问共享文件</span><br><span class="line">int count = 0; //记录当前有几个读进程在访问文件</span><br><span class="line">semaphore mutex = 1; //用于保证对于count变量的互斥访问</span><br><span class="line">semaphore w = 1; //用于实现“写优先”(解决写进程饥饿)</span><br><span class="line"></span><br><span class="line">writer() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(w);</span><br><span class="line">        P(rw); //写之前“加锁”</span><br><span class="line">        写文件...；</span><br><span class="line">        V(rw); //写之后“解锁”</span><br><span class="line">        V(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        p(W);</span><br><span class="line">        P(mutex); //各读进程互斥的访问count</span><br><span class="line">        if (count == 0) &#123;</span><br><span class="line">            P(rw); //第一个读进程负责“加锁”</span><br><span class="line">        &#125;</span><br><span class="line">        count ++; //访问文件的进程数 +1</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(w);</span><br><span class="line">        读文件；</span><br><span class="line">        P(mutex);</span><br><span class="line">        count --; //访问文件的进程数-1</span><br><span class="line">        if (count == 0) &#123;</span><br><span class="line">            V(rw); //最后一个读进程负责“解锁”</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="知识回顾与重要考点-2"><a href="#知识回顾与重要考点-2" class="headerlink" title="知识回顾与重要考点"></a>知识回顾与重要考点</h5><p>读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路。 其核心思想在于设置一个计数器count用来记录当前正在访问共享文件的进程数，我们可以用count的值来判断当前进入的进程是否是第一个&#x2F;最后一个进程，从而做出不同的处理。 另外，对count变量的检查和赋值不能一气呵成导致了一些错误，如果要<strong>实现“一气呵成”，自然应该想到使用互斥信号量</strong> 最后，还需要体会是如何解决写饥饿问题的</p>
<h3 id="2-3-10-哲学家进餐问题"><a href="#2-3-10-哲学家进餐问题" class="headerlink" title="2.3_10 哲学家进餐问题"></a>2.3_10 哲学家进餐问题</h3><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学 家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时， 才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲 学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
<h5 id="问题分析-3"><a href="#问题分析-3" class="headerlink" title="问题分析"></a>问题分析</h5><p>1.关系分析：系统中有五个哲学家进程，五位哲学家与左右邻居对其中间筷子的访问是互斥关系 2.整理思路：这个问题中只有互斥关系，但与之前的问题不同的是，每个哲学家进程需要同时拥有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓 3.信号量设置：定义互斥信号量数组chopstick[5] &#x3D; {1,1,1,1,1} 用于实现对5个筷子的互斥访问。并对哲学家按0-4编号，哲学界左边的筷子编号为i，右边筷子的编号为（i + 1）% 5。 如何防止死锁的发生</p>
<ul>
<li>可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐，这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</li>
<li>要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家正好相反。用这种方式可以保证如果两个相邻两个哲学家都想吃饭，那么只会有一个可以拿起第一只筷子，另一个就会被阻塞，这就避免了占有一只再等待另一只的情况</li>
<li>仅当哲学家左右都有筷子时才允许进餐 （这种方法不能保证当两边的筷子可用时，哲学家可以进餐）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1,1,1,1,1&#125;;</span><br><span class="line">semaphore mutex = 1; //表示哲学家左右是否有筷子</span><br><span class="line">pi() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(chopstick[i]);</span><br><span class="line">        P(chopstick[(i+1)%5]);</span><br><span class="line">        V(mutex);</span><br><span class="line">        吃饭...;</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i+1)%5]);</span><br><span class="line">        思考...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="知识回顾与重要考点-3"><a href="#知识回顾与重要考点-3" class="headerlink" title="知识回顾与重要考点"></a>知识回顾与重要考点</h5><p>哲学家进餐问题的关键是解决进餐死锁 这些进程之间只存在互斥关系，但与之前不同的是每个进程需要持有两个临界资源，因此有了“死锁”的问题隐患 如果在考试中遇到了一个进程需要持有多个临界资源的情况，应该参考哲学家问题的思想，分析题目中的进程之间是否会发生循环等待，是否会发生死锁 可以参考哲学家就餐问题解决死锁的三种思路</p>
<h3 id="2-3-11-管程"><a href="#2-3-11-管程" class="headerlink" title="2.3_11 管程"></a>2.3_11 管程</h3><h5 id="（1）为什么要引入管程"><a href="#（1）为什么要引入管程" class="headerlink" title="（1）为什么要引入管程"></a>（1）为什么要引入管程</h5><p>信号量机制存在到的问题：编写程序困难，易出错 能不能设计一种机制，让程序员写程序时不需要关注复杂的P,V操作，让写代码更加轻松 1973年，Brinch Hansen 首次在程序设计语言（Pascal）中引入了“管程”成分——一种高级同步机制</p>
<h5 id="（2）管程的定义和基本特征"><a href="#（2）管程的定义和基本特征" class="headerlink" title="（2）管程的定义和基本特征"></a>（2）管程的定义和基本特征</h5><p>管程是一种特殊的软件模块，有这些部分组成</p>
<ol>
<li>局域于管程的<strong>共享数据结构</strong>说明；</li>
<li>对该数据结构进行操作的<strong>一组过程</strong>；</li>
<li>对局部与管程的共享数据设置初始值的语句；</li>
<li>管程有一个名字；</li>
</ol>
<p>管程的基本特征：</p>
<ol>
<li>局部与管程的数据只能被局部与管程的过程所访问</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li>
<li><strong>每次仅允许一个进程在管程内执行某个内部过程</strong></li>
</ol>
<h5 id="拓展1：使用管程解决生产者消费者问题"><a href="#拓展1：使用管程解决生产者消费者问题" class="headerlink" title="拓展1：使用管程解决生产者消费者问题"></a>拓展1：使用管程解决生产者消费者问题</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer &#123;</span><br><span class="line">    condition full,empty; //条件变量用来实现同步</span><br><span class="line">    int count = 0; //缓冲区中的产品数</span><br><span class="line">    void insert (Item item) &#123;</span><br><span class="line">        if (count == N) &#123;</span><br><span class="line">            wait(full);</span><br><span class="line">        &#125;</span><br><span class="line">        count ++:</span><br><span class="line">        insert_item(item);</span><br><span class="line">        if (count == 1) &#123;</span><br><span class="line">            signal(empty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Item remove() &#123;</span><br><span class="line">        if (count == 1) &#123;</span><br><span class="line">            wait(empty);</span><br><span class="line">        &#125;</span><br><span class="line">        count --;</span><br><span class="line">        if (count == N - 1) &#123;</span><br><span class="line">            signal(full);</span><br><span class="line">        &#125;</span><br><span class="line">        return remove_item();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">producer() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        item = 生产一个产品;</span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        item = PruducerConsumer.remove();</span><br><span class="line">        消费产品item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入管程的目的无非就是更方便的实现进程互斥和同步</p>
<ol>
<li>需要在管程中定义共享数据</li>
<li>需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数</li>
<li>只有<strong>通过这些“入口”才能访问共享数据</strong></li>
<li>管程中有很多“入口”，但是<strong>每次只能开放其中一个入口</strong>，且<strong>每次只能让一个进程或者线程进入</strong>（注意：互斥是由编辑器实现的）</li>
<li>可以在管程中设置<strong>条件变量</strong>及<strong>等待&#x2F;唤醒操作</strong>解决同步问题，可以让一个进程或者线程在条件变量上等待；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒</li>
</ol>
<h5 id="拓展2-java中类似管程的机制"><a href="#拓展2-java中类似管程的机制" class="headerlink" title="拓展2 java中类似管程的机制"></a>拓展2 java中类似管程的机制</h5><p>synchronized关键字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static class monitor &#123;</span><br><span class="line">    private Item buffer[] = new Item[N];</span><br><span class="line">    private int count = 0;</span><br><span class="line"></span><br><span class="line">    public synchronized void insert(Item item) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-1-死锁的概念"><a href="#2-4-1-死锁的概念" class="headerlink" title="2.4_1 死锁的概念"></a>2.4_1 死锁的概念</h3><h5 id="（1）什么是死锁"><a href="#（1）什么是死锁" class="headerlink" title="（1）什么是死锁"></a>（1）什么是死锁</h5><p>在并发环境下，各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象</p>
<h5 id="（2）死锁，饥饿，死循环的区别"><a href="#（2）死锁，饥饿，死循环的区别" class="headerlink" title="（2）死锁，饥饿，死循环的区别"></a>（2）死锁，饥饿，死循环的区别</h5><p>死锁：在并发环境下，各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象 饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。 死循环：某进程执行过程中一直跳不出某个循环的现象，有时是程序逻辑bug导致，有时是程序员设计</p>
<h5 id="（3）死锁产生的必要条件"><a href="#（3）死锁产生的必要条件" class="headerlink" title="（3）死锁产生的必要条件"></a>（3）死锁产生的必要条件</h5><ol>
<li><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁</li>
<li><strong>不可剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</li>
<li><strong>请求和保持条件</strong>：进程已经保持了一个至少一个资源，但是又提出了新的资源请求，而资源已经被其他进程占有，此时请求被阻塞，但是又对自己已有资源保持不放</li>
<li><strong>循环等待条件</strong>：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</li>
</ol>
<p>如果同类资源数大于1，即时有循环等待也未必发生死锁 但如果同类资源只有一个，发生循环等待必定发生死锁</p>
<h5 id="（4）什么时候会发生死锁"><a href="#（4）什么时候会发生死锁" class="headerlink" title="（4）什么时候会发生死锁"></a>（4）什么时候会发生死锁</h5><ol>
<li>对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能会引起死锁，对可剥夺的资源（CPU）是不会引起死锁的</li>
<li>进程推进顺序非法。请求和释放资源的顺序不当</li>
<li>信号量的使用不当</li>
</ol>
<p>总之，对不可剥夺资源的不合理分配，可能导致死锁</p>
<h5 id="（5）死锁的处理策略"><a href="#（5）死锁的处理策略" class="headerlink" title="（5）死锁的处理策略"></a>（5）死锁的处理策略</h5><ol>
<li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个</li>
<li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li>
<li>死锁的检测和解除。允许死锁的发生，不过操作系统会检测出死锁的发生，然后采取某种措施解除死锁</li>
</ol>
<h3 id="2-4-2-死锁的处理——预防死锁"><a href="#2-4-2-死锁的处理——预防死锁" class="headerlink" title="2.4_2 死锁的处理——预防死锁"></a>2.4_2 死锁的处理——预防死锁</h3><h5 id="（1）破坏互斥条件"><a href="#（1）破坏互斥条件" class="headerlink" title="（1）破坏互斥条件"></a>（1）破坏互斥条件</h5><p>互斥条件：只有对必须互斥使用的资源争抢才会导致死锁 如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如：SPOOLing技术，操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备 缺点：并不是所有设备可以改为共享设备，为了系统安全，有很多地方必须保持这种互斥条件，因此很多时候不能破坏互斥条件</p>
<h5 id="（2）破坏不剥夺条件"><a href="#（2）破坏不剥夺条件" class="headerlink" title="（2）破坏不剥夺条件"></a>（2）破坏不剥夺条件</h5><p>不剥夺条件：进程所获得得资源在未使用完之前，不能由其他进程强行夺走，只能主动释放 方案1：当某个进程请求新的资源得不到满足时，它必须立即释放所保持的所有资源，待以后需要的使用重新申请。也就是说，即时某些资源尚未使用完，也要主动释放，从而破坏了不可剥夺条件 方法2:当某个进程需要的资源被其他进程占有的时候，可以由操作系统协助，将需要的资源强行剥夺。这种方式一般考虑进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用) 缺点：</p>
<ol>
<li>实现起来比较复杂</li>
<li>释放已获得的资源可能会导致前一阶段的工作实效。因此这种方法一般使用与易宝存和恢复状态的资源，如cpu</li>
<li>反复的申请和释放资源会增加系统开销，降低系统的吞吐量</li>
<li>若采用方案1，会导致饥饿</li>
</ol>
<h5 id="（3）破坏请求和保持条件"><a href="#（3）破坏请求和保持条件" class="headerlink" title="*（3）破坏请求和保持条件"></a>*（3）破坏请求和保持条件</h5><p>请求和保证条件：进程已经持有了至少一个资源，又需要一个被其他进程持有的资源，此时请求进程被阻塞但又不释放已经持有的资源 可以采用<strong>静态分配方</strong>法，即进程在运行前一次申请完它所需要的全部资源，在他的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，改进程就不会再请求别的任何资源了 改策略实现起来简单，但也有缺点 有些资源可能只需要使用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，<strong>资源换利用率极低</strong>。此外，<strong>可能导致某些进程饥饿</strong></p>
<h5 id="（4）破坏循环等待条件"><a href="#（4）破坏循环等待条件" class="headerlink" title="（4）破坏循环等待条件"></a>（4）破坏循环等待条件</h5><p>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求 可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（编号相同的资源）一次申请完 原理分析：一个进程只有已经占有小编号的资源时，才有资格更申请大编号的资源，按此规则，已经持有大编号资源的进程不可能逆向的回来申请小编号的资源，从而不会产生循环等待现象 缺点：</p>
<ol>
<li>不方便添加新的设备，可能需要重新下编号</li>
<li>进程实际使用资源的顺序可能和编号递增的顺序不一致，会导致资源浪费</li>
<li>必须按照规定次序申请资源，用户编程很麻烦</li>
</ol>
<h3 id="2-4-3-死锁的处理策略——避免死锁"><a href="#2-4-3-死锁的处理策略——避免死锁" class="headerlink" title="2.4_3 死锁的处理策略——避免死锁"></a>2.4_3 死锁的处理策略——避免死锁</h3><h5 id="（1）什么是安全序列"><a href="#（1）什么是安全序列" class="headerlink" title="（1）什么是安全序列"></a>（1）什么是安全序列</h5><p>你是一位成功的银行家，手里掌握着100个亿的资金… 有三个企业想找你贷款，分别是企业B、企业A、企业T，为描述方便，简称BAT。 B表示:“大哥，我最多会跟你借70亿…” A表示:“大哥，我最多会跟你借40亿…” 干表示:“大哥，我最多会跟你借50亿..” 然而…江湖中有个不成文的规矩:<strong>如果你借给企业的钱总数达不到企业提出的最</strong> <strong>大要求，那么不管你之前给企业借了多少钱，那些钱都拿不回来了….</strong> 刚开始，BAT三个企业分别从你这儿借了20、10、30亿….</p>
<h5 id="（2）安全状态，不安全状态，死锁的联系"><a href="#（2）安全状态，不安全状态，死锁的联系" class="headerlink" title="（2）安全状态，不安全状态，死锁的联系"></a>（2）安全状态，不安全状态，死锁的联系</h5><p>安全序列：系统按照这种序列分配资源，则每个进程都能顺利完成。只要找出一个安全序列，系统就是安全状态，当然，安全序列可以有多个 如果分配了资源后，系统找不到任何一个安全序列，系统就进入了不安全状态，就以为着之后可能所有进程都无法顺利的执行下去，当然，如果有进程提前归还了一部分资源，系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况 如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就有可能发生死锁 因此可以在系统分配资源之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源的分配请求。这也是“银行家算法”的核心思想。</p>
<h5 id="（3）银行家算法"><a href="#（3）银行家算法" class="headerlink" title="（3）银行家算法"></a>（3）银行家算法</h5><p>银行家算法是荷兰学者Dijkstra为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况，后来算法被用在操作系统中，用于<strong>避免死锁</strong>。 <strong>核心思想</strong>：在进程提出资源申请时，先预判这次分配是否会导致系统进入不安全状态，如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞 思考：bat的例子中，只有一种类型的资源——钱，但是在计算机系统中有多种资源，怎么将算法拓展为多种资源的情况呢</p>
<h5 id="（4）知识回顾于重要考点"><a href="#（4）知识回顾于重要考点" class="headerlink" title="（4）知识回顾于重要考点"></a>（4）知识回顾于重要考点</h5><p>数据结构: 长度为m的一维数组 Available表示还有多少可用资源 n_m矩阵Max表示各进程对资源的最大需求数 n_m矩阵Allocation表示已经给各进程分配了多少资源 Max-Allocation &#x3D; Need矩阵表示各进程最多还需要多少资源 用长度为m的一位数组 Request表示进程此次申请的各种资源数 银行家算法步骤: ①检查此次申请是否超过了之前声明的最大需求数 ②检查此时系统剩余的可用资源是否还能满足这次请求 ③试探着分配，更改各数据结构 ④用安全性算法检查此次分配是否会导致系统进入不安全状态 安全性算法步骤: 检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列， 并把该进程持有的资源全部回收。 不断重复上述过程，看最终是否能让所有进程都加入安全序列。 如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就有可能发生死锁</p>
<h3 id="2-4-4-死锁的处理策略——死锁的检测和解除"><a href="#2-4-4-死锁的处理策略——死锁的检测和解除" class="headerlink" title="2.4_4 死锁的处理策略——死锁的检测和解除"></a>2.4_4 死锁的处理策略——死锁的检测和解除</h3><h5 id="（1）死锁的检测"><a href="#（1）死锁的检测" class="headerlink" title="（1）死锁的检测"></a>（1）死锁的检测</h5><p>为了能对系统中是否已经发生了死锁进行检测，必须：</p>
<ol>
<li>用某种数据结构来保存资源请求和分配信息</li>
<li>提供一种算法，根据上述信息来检测系统是否已进入死锁状态</li>
</ol>
<p>资源分配图 两种节点</p>
<ul>
<li>进程节点：对应一个进程</li>
<li>资源节点：对应一类资源，一类资源可能有多个</li>
</ul>
<p>两种边</p>
<ul>
<li>进程节点 -&gt; 资源节点 ：表示进程想要申请几个资源（每一条边代表一个）</li>
<li>资源节点 -&gt; 进程节点 ： 表示为进程分配了几个资源（每一条边代表一个）</li>
</ul>
<p>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会被阻塞的，可以顺利的执行下去 如果这个进程执行结束后吧资源归还给系统，就可以是某个正在等待资源的进程被激活，并且顺利的执行下去 相应的，这些被激活的进程执行完了之后又会归还一些资源，这样又可能会激活另外一些被阻塞的进程 如果按照上述过程分析，最终能消除所有边，就称这个图是可完全简化的，此时一定没有发生死锁（想到与找到一个安全序列） 如果最终不能消除所有边，那么就发生了死锁 最终连着边的进程就是处于死锁状态的进程</p>
<h5 id="（2）死锁的解除"><a href="#（2）死锁的解除" class="headerlink" title="（2）死锁的解除"></a>（2）死锁的解除</h5><p>解除死锁的主要方法有：</p>
<ol>
<li><strong>资源剥夺法</strong>：挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是一个防止被挂起的进程长时间得不到资源而饥饿</li>
<li><strong>撤销进程法</strong>：（终止进程法）强制撤销部分，甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但付出的代价可能会很大。因为有些进程可能已经运行了很长时间，或者已经接近结束了，一旦被终止可能功亏一篑</li>
<li><strong>进程回退法</strong>：让一个或多个死锁进程回退到足以避免死锁的地步，这就要系统记录进程的历史消息，设置还原点</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">廖涛</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://taoblog421.cn/article/bb449d20.html">http://taoblog421.cn/article/bb449d20.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://taoblog421.cn" target="_blank">Taoblog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="https://edu-cubeonline.oss-cn-chengdu.aliyuncs.com/8338e032aa164b37a69adee487bf10a81.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/article/1535395b.html"><img class="prev-cover" src="https://edu-cubeonline.oss-cn-chengdu.aliyuncs.com/8338e032aa164b37a69adee487bf10a81.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">三.内存</div></div></a></div><div class="next-post pull-right"><a href="/article/8b5271f8.html"><img class="next-cover" src="https://edu-cubeonline.oss-cn-chengdu.aliyuncs.com/8338e032aa164b37a69adee487bf10a81.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">二.进程，处理机调度与死锁（一）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/article/1535395b.html" title="三.内存"><img class="cover" src="https://edu-cubeonline.oss-cn-chengdu.aliyuncs.com/8338e032aa164b37a69adee487bf10a81.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-03</div><div class="title">三.内存</div></div></a></div><div><a href="/article/7568c2fe.html" title="一.操作系统引论"><img class="cover" src="https://edu-cubeonline.oss-cn-chengdu.aliyuncs.com/8338e032aa164b37a69adee487bf10a81.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-02</div><div class="title">一.操作系统引论</div></div></a></div><div><a href="/article/8b5271f8.html" title="二.进程，处理机调度与死锁（一）"><img class="cover" src="https://edu-cubeonline.oss-cn-chengdu.aliyuncs.com/8338e032aa164b37a69adee487bf10a81.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-02</div><div class="title">二.进程，处理机调度与死锁（一）</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%8C%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-text">2.3_1 进程同步，进程互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">2.3_2 进程互斥的软件实现方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">2.3_3 进程互斥的硬件实现方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-text">2.3_4 信号量机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-5-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-text">2.3_5 信号量机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-6-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">2.3_6 生产者消费者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pv%E6%93%8D%E4%BD%9C%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-text">pv操作题目分析步骤：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E4%B8%8E%E9%87%8D%E8%A6%81%E8%80%83%E7%82%B9"><span class="toc-text">知识回顾与重要考点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-7-%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">2.3_7 多生产者消费者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E4%B8%8E%E9%87%8D%E8%A6%81%E8%80%83%E7%82%B9-1"><span class="toc-text">知识回顾与重要考点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-8-%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">2.3_8 吸烟者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-1"><span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-1"><span class="toc-text">问题分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-9-%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">2.3_9 读者-写者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-2"><span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-2"><span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E4%B8%8E%E9%87%8D%E8%A6%81%E8%80%83%E7%82%B9-2"><span class="toc-text">知识回顾与重要考点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-10-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-text">2.3_10 哲学家进餐问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-3"><span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-3"><span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E4%B8%8E%E9%87%8D%E8%A6%81%E8%80%83%E7%82%B9-3"><span class="toc-text">知识回顾与重要考点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-11-%E7%AE%A1%E7%A8%8B"><span class="toc-text">2.3_11 管程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E7%AE%A1%E7%A8%8B"><span class="toc-text">（1）为什么要引入管程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%AE%A1%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-text">（2）管程的定义和基本特征</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%93%E5%B1%951%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%AE%A1%E7%A8%8B%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">拓展1：使用管程解决生产者消费者问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%93%E5%B1%952-java%E4%B8%AD%E7%B1%BB%E4%BC%BC%E7%AE%A1%E7%A8%8B%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-text">拓展2 java中类似管程的机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">2.4_1 死锁的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81"><span class="toc-text">（1）什么是死锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%AD%BB%E9%94%81%EF%BC%8C%E9%A5%A5%E9%A5%BF%EF%BC%8C%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">（2）死锁，饥饿，死循环的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-text">（3）死锁产生的必要条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81"><span class="toc-text">（4）什么时候会发生死锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-text">（5）死锁的处理策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-text">2.4_2 死锁的处理——预防死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%A0%B4%E5%9D%8F%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6"><span class="toc-text">（1）破坏互斥条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%A0%B4%E5%9D%8F%E4%B8%8D%E5%89%A5%E5%A4%BA%E6%9D%A1%E4%BB%B6"><span class="toc-text">（2）破坏不剥夺条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%A0%B4%E5%9D%8F%E8%AF%B7%E6%B1%82%E5%92%8C%E4%BF%9D%E6%8C%81%E6%9D%A1%E4%BB%B6"><span class="toc-text">*（3）破坏请求和保持条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E7%A0%B4%E5%9D%8F%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="toc-text">（4）破坏循环等待条件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5%E2%80%94%E2%80%94%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-text">2.4_3 死锁的处理策略——避免死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%89%E5%85%A8%E5%BA%8F%E5%88%97"><span class="toc-text">（1）什么是安全序列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81%EF%BC%8C%E4%B8%8D%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81%EF%BC%8C%E6%AD%BB%E9%94%81%E7%9A%84%E8%81%94%E7%B3%BB"><span class="toc-text">（2）安全状态，不安全状态，死锁的联系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-text">（3）银行家算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E4%BA%8E%E9%87%8D%E8%A6%81%E8%80%83%E7%82%B9"><span class="toc-text">（4）知识回顾于重要考点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4"><span class="toc-text">2.4_4 死锁的处理策略——死锁的检测和解除</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-text">（1）死锁的检测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E9%99%A4"><span class="toc-text">（2）死锁的解除</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://edu-cubeonline.oss-cn-chengdu.aliyuncs.com/8338e032aa164b37a69adee487bf10a81.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 廖涛</div><div class="footer_custom_text">©版权说明：本网站所有内容均收集于互联网或自己创作,<br>方便于网友与自己学习交流，如有侵权，请<a href = 'http://taoblog421.cn/messageboard/'>留言</a>，立即处理<br><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><span>备案号：陇ICP备2020004464号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main01.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'UdlOld4ASbFChikw4W0qkuA3-gzGzoHsz',
      appKey: 'j7HSw45F6iXY7fRL8jAtFIAC',
      avatar: 'retro',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="true" data-text="三民主义,吾党所宗,以建民国,以进大同" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>